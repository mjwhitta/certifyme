#!/usr/bin/env bash
# A script to quickly generate a root CA and client/server
# certificates.
# by Miles Whittaker <mjwhitta@gmail.com>
#
# --------------------------------------------------------------------
# The MIT License (MIT)
#
# Copyright (c) 2018 Miles Whittaker
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# --------------------------------------------------------------------

create_ca() {
    setup "${CACN:-Self-signed CA}"
    create_key ca.key

    if [[ ! -f ca/ca.cert.pem ]]; then
        info "Generating ca.cert.pem"
        openssl req -batch $sslcnf -days +${CADAYS:-11688} \
            -extensions v3_ca -key private/ca.key.pem -new \
            -out ca/ca.cert.pem -passin pass:${CAPASS:-password} \
            -sha256 -subj "/$subj" -x509
    fi

    if [[ -n $CREATE_DER ]]; then
        if [[ ! -f ca/ca.cert.der ]] && [[ -f ca/ca.cert.pem ]]; then
            info "Generating ca.cert.der"
            openssl x509 -in ca/ca.cert.pem -inform pem \
                -out ca/ca.cert.der -outform der
        fi
    fi

    fix_perms

    # Symlink files
    ln -sf ../ca/ca.cert.pem pems/
    [[ -z $CREATE_DER ]] || ln -sf ../ca/ca.cert.der ders/
}

create_cert() {
    setup "$1"

    case "$2" in
        "client")
            cert="$1.client.cert"
            csr="$1.client.csr"
            key="$1.client.key"
            ;;
        *)
            cert="$1.cert"
            csr="$1.csr"
            key="$1.key"
            ;;
    esac

    create_key $key

    # Shouldn't have a csr and no certificate
    [[ -f certs/$cert.pem ]] || rm -f csr/$csr.pem

    if [[ ! -f csr/$csr.pem ]]; then
        info "Generating $csr.pem"
        openssl req -batch $sslcnf -key private/$key.pem \
            -new -out csr/$csr.pem -sha256
    fi

    if [[ ! -f certs/$cert.pem ]]; then
        info "Generating $cert.pem"
        openssl ca -batch $sslcnf -extensions ${2}_cert \
            -in csr/$csr.pem -notext -out certs/$cert.pem
    fi

    if [[ -n $CREATE_DER ]]; then
        if [[ ! -f certs/$cert.der ]] &&
           [[ -f certs/$cert.pem ]]
        then
            info "Generating $cert.der"
            openssl x509 -in certs/$cert.pem -inform pem \
                -out certs/$cert.der -outform der
        fi
    fi

    rm -f *.old
    for junk in $(ls certs | \grep -Ev "\.cert\.(der|pem)"); do
        rm -f certs/$junk
    done; unset junk
    find certs -size 0 -exec rm -f {} +

    fix_perms

    # Symlink files
    ln -sf ../certs/$cert.pem pems/
    [[ -z $CREATE_DER ]] || ln -sf ../certs/$cert.der ders/
}

create_dh() {
    if [[ ! -f dh/dh2048.pem ]]; then
        info "Generating dh2048.pem"
        openssl dhparam -out dh/dh2048.pem 2048
    fi

    if [[ -n $CREATE_DER ]]; then
        if [[ ! -f dh/dh2048.der ]] && [[ -f dh/dh2048.pem ]]; then
            info "Generating dh2048.der"
            openssl dhparam -in dh/dh2048.pem -inform pem \
                -out dh/dh2048.der -outform der
        fi
    fi

    fix_perms

    # Symlink files
    ln -sf ../dh/dh2048.pem pems/
    [[ -z $CREATE_DER ]] || ln -sf ../dh/dh2048.der ders/
}

create_key() {
    if [[ ! -f private/$1.pem ]]; then
        info "Generating $1.pem"
        openssl genrsa -out private/$1.pem -passout pass: 2048
    fi

    if [[ -n $CREATE_DER ]]; then
        if [[ ! -f private/$1.der ]] && [[ -f private/$1.pem ]]; then
            info "Generating $1.der"
            openssl pkcs8 -in private/$1.pem -inform pem \
                -out private/$1.der -outform der -passout pass: -topk8
        fi
    fi

    fix_perms

    # Symlink files
    ln -sf ../private/$1.pem pems/
    [[ -z $CREATE_DER ]] || ln -sf ../private/$1.der ders/
}

err() { echo -e "\e[31m[!] ${2}\e[0m"; exit $1; }

fix_perms() {
    find ca certs dh private -type d -exec chmod 700 {} +
    find ca certs dh private -type f -exec chmod 400 {} +
    chmod -R go-rwx .
}

info() { echo -e "\e[37m[+] ${@}\e[0m"; }

remove_from_db() {
    [[ $# -eq 1 ]] || return 0
    [[ -f ca/ca.cert.pem ]] || return 0
    [[ -f index.db ]] || return 0
    remove="$(\grep -m 1 "/CN=$1" index.db | awk '{print $3,$5}')"
    [[ -n $remove ]] || return 0

    warn "Removing $1 from the database"

    # Update the index.db
    serial="${remove/ */}"
    sed -i -r "/\s+$serial\s+/d" index.db

    # Remove certificate, csr, and key
    host="$(echo "$remove" | awk -F "=" '{print $NF}')"
    rm -f */$host.*
}

setup() {
    subj="CN=$1"
    [[ -z $UNIT ]] || subj="OU=$UNIT/$subj"
    [[ -z $COMPANY ]] || subj="O=$COMPANY/$subj"
    [[ -z $CITY ]] || subj="L=$CITY/$subj"
    [[ -z $STATE ]] || subj="ST=$STATE/$subj"
    [[ -z $COUNTRY ]] || subj="C=$COUNTRY/$subj"

    mkdir -p ca certs csr dh pems private
    [[ -z $CREATE_DER ]] || mkdir -p ders
    touch index.db index.db.attr
    if [[ ! -f index.db.serial ]]; then
        head -c 2 /dev/urandom | xxd -p >index.db.serial
    fi

    sed \
        -e "s/TODO_CERTDAYS/${CERTDAYS:-5844}/g" \
        -e "s/TODO_CITY/\"${CITY:-delete}\"/g" \
        -e "s/TODO_CN/\"$1\"/g" \
        -e "s/TODO_COMPANY/\"${COMPANY:-delete}\"/g" \
        -e "s/TODO_COUNTRY/\"${COUNTRY:-delete}\"/g" \
        -e "s/TODO_STATE/\"${STATE:-delete}\"/g" \
        -e "s/TODO_UNIT/\"${UNIT:-delete}\"/g" \
        -e "/delete/d" \
        $tmpcnf >certifyme.openssl.cnf
}

undo() {
    [[ -f ca/ca.cert.pem ]] || return 0
    [[ -f index.db ]] || return 0
    rollback="$(tail -n 1 index.db | awk '{print $3,$5}')"
    [[ -n $rollback ]] || return 0

    host="$(echo "$rollback" | awk -F "=" '{print $NF}')"
    warn "Rolling back database prior to $host"

    # Rollback the index.db
    serial="${rollback/ */}"
    echo "$serial" >index.db.serial
    sed -i -r "/\s+$serial\s+/d" index.db

    # Remove certificate, csr, and key
    rm -f */$host.*
}

usage() {
    echo "Usage: ./${0/*\//} [OPTIONS] [host1]...[hostN]"
    echo "Options:"
    echo "    -c, --client=HOST    Create client certificate (can be"
    echo "                         used more than once)"
    echo "    --conf=CONFIG        Use the specified certifyme.conf"
    echo "                         (default: $pki/certifyme.conf)"
    echo "    -d, --dh             Create Diffie-Hellman parameters"
    echo "    -h, --help           Display this help message"
    echo "    -p, --pki=DIR        Use specified directory for PKI"
    echo "                         (default: $pki)"
    echo "    -r, --rm=HOST        Remove a certificate (does NOT"
    echo "                         revoke)"
    echo "    --sample-config      Generate sample certifyme.conf"
    echo "    -u, --undo           Rollback most recently generated"
    echo "                         certificate"
    echo "    -w, --wipe           Wipe CA, certificates, dh params"
    echo "                         and keys"
    echo
    exit $1
}

warn() { echo -e "\e[33m[-] ${@}\e[0m"; }

wipe_pki() {
    warn "Wiping PKI"
    rm -rf ca certs csr ders dh index.db* pems private
}

declare -a args clients
unset config dh remove
action="generate"
pki="${CERTIFYME_PKI:-.}"
sslcnf="-config certifyme.openssl.cnf"
tmpcnf="/tmp/certifyme.openssl.cnf"

while [[ $# -gt 0 ]]; do
    case "$1" in
        "--") shift && args+=("$@") && break ;;
        "-c"|"--client"*)
            case "$1" in
                "--"*"="*) arg="${1#*=}"; [[ -n $arg ]] || usage 1 ;;
                *) shift; [[ $# -gt 0 ]] || usage 1; arg="$1" ;;
            esac
            clients+=("$arg")
            ;;
        "--conf"*)
            case "$1" in
                "--"*"="*)
                    arg="$(echo "$1" | sed -r "s/[^=]+=//")"
                    [[ -n $arg ]] || usage 1
                    ;;
                *) shift; [[ $# -gt 0 ]] || usage 1; arg="$1" ;;
            esac
            config="$arg"
            ;;
        "-d"|"--dh") dh="true" ;;
        "-h"|"--help") usage 0 ;;
        "-p"|"--pki"*)
            case "$1" in
                "--"*"="*)
                    arg="$(echo "$1" | sed -r "s/[^=]+=//")"
                    [[ -n $arg ]] || usage 1
                    ;;
                *) shift; [[ $# -gt 0 ]] || usage 1; arg="$1" ;;
            esac
            pki="$arg"
            ;;
        "-r"|"--rm"*)
            case "$1" in
                "--"*"="*)
                    arg="$(echo "$1" | sed -r "s/[^=]+=//")"
                    [[ -n $arg ]] || usage 1
                    ;;
                *) shift; [[ $# -gt 0 ]] || usage 1; arg="$1" ;;
            esac
            action="remove"
            remove="$arg"
            ;;
        "--sample-config") action="config" ;;
        "-u"|"--undo") action="undo" ;;
        "-w"|"--wipe") action="wipe" ;;
        *) args+=("$1") ;;
    esac
    shift
done
[[ -z ${args[@]} ]] || set -- "${args[@]}"

[[ -n $(command -v openssl) ]] || err 2 "openssl is not installed"

# Source config if specified
[[ -z $config ]] || [[ ! -f $config ]] || . $config

# Operate from with-in PKI directory
mkdir -p $pki
cd $pki

# Deprecated params
[[ -n $config ]] || [[ ! -f params ]] || . params

# Source config in pki directory if one wasn't specified
[[ -n $config ]] || [[ ! -f certifyme.conf ]] || . certifyme.conf

case "${CREATE_DER:-true}" in
    "T"|"t"|"True"|"true"|"Y"|"y"|"Yes"|"yes") CREATE_DER="true" ;;
    *) unset CREATE_DER ;;
esac

cat >$tmpcnf <<EOF
# OpenSSL configuration file.

dir = .

[ ca ]
default_ca = CA_default

[ CA_default ]
certs = \$dir/certs
new_certs_dir = \$dir/certs
database = \$dir/index.db
serial = \$dir/index.db.serial
RANDFILE = \$dir/private/.rand

certificate = \$dir/ca/ca.cert.pem
private_key = \$dir/private/ca.key.pem

default_md = sha256

name_opt = CA_default
cert_opt = CA_default
default_days = TODO_CERTDAYS
email_in_dn = no
preserve = no
policy = policy_string

[ policy_string ]
countryName = optional
stateOrProvinceName = optional
organizationName = optional
organizationalUnitName = optional
commonName = supplied
emailAddress = optional

[ policy_any ]
countryName = optional
stateOrProvinceName = optional
localityName = optional
organizationName = optional
organizationalUnitName = optional
commonName = supplied
emailAddress = optional

[ req ]
default_bits = 2048
distinguished_name = req_distinguished_name
string_mask = utf8only

default_md = sha256

x509_extensions = v3_ca

[ req_distinguished_name ]
countryName = Country Name (2 letter code) # TODO_COUNTRY
countryName_default = TODO_COUNTRY
countryName_min = 2 # TODO_COUNTRY
countryName_max = 2 # TODO_COUNTRY

stateOrProvinceName = State or Province Name (full name) # TODO_STATE
stateOrProvinceName_default = TODO_STATE

localityName = Locality Name (eg, city) # TODO_CITY
localityName_default = TODO_CITY

0.organizationName = Organization Name (eg, company) # TODO_COMPANY
0.organizationName_default = TODO_COMPANY

organizationalUnitName = Organizational Unit Name (eg, section) # TODO_UNIT
organizationalUnitName_default = TODO_UNIT

commonName = Common Name (FQDN for server certificates)
commonName_default = TODO_CN
commonName_max = 64

[ req_attributes ]

[ v3_ca ]
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints = critical, CA:true
keyUsage = critical, digitalSignature, cRLSign, keyCertSign

[ server_cert ]
basicConstraints = CA:false
nsCertType = server
nsComment = "OpenSSL genereated server certificate"
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @subject_alt_names

[ client_cert ]
basicConstraints = CA:false
nsCertType = client, email
nsComment = "OpenSSL genereated client certificate"
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
keyUsage = critical, digitalSignature, keyEncipherment, nonRepudiation
extendedKeyUsage = clientAuth, emailProtection
subjectAltName = @subject_alt_names

[ subject_alt_names ]
DNS.1 = TODO_CN
EOF

case "$action" in
    "config")
        echo "# Adjust and uncomment these values as needed"
        echo
        echo "## Certificate related options"
        echo
        echo "# CACN=\"Self-signed CA\""
        echo "# CADAYS=11688"
        echo "# CAPASS=\"password\""
        echo "# CERTDAYS=5844"
        echo "# CITY=\"City name\""
        echo "# COMPANY=\"Company name\""
        echo "# COUNTRY=\"US\""
        echo "# STATE=\"State name\""
        echo "# UNIT=\"Department\""
        echo
        echo "## certifyme related options"
        echo
        echo "# CREATE_DER=\"true\""
        ;;
    "generate")
        create_ca
        [[ -z $dh ]] || create_dh
        for client in "${clients[@]}"; do
            create_cert $client "client"
        done; unset client
        for host in "$@"; do
            create_cert $host "server"
        done; unset host
        ;;
    "remove") remove_from_db $remove ;;
    "undo") undo ;;
    "wipe") wipe_pki ;;
esac

rm -f certifyme.openssl.cnf $tmpcnf
